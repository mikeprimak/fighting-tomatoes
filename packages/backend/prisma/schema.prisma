// FightCrewApp Database Schema
// Modern PostgreSQL schema using Prisma ORM

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============== USERS ==============
model User {
  id                String    @id @default(uuid())
  email             String    @unique
  emailVerified     Boolean   @default(false)
  emailVerificationToken String?
  password          String?   // nullable for OAuth users
  firstName         String?
  lastName          String?
  displayName       String?
  avatar            String?
  
  // Authentication
  authProvider      AuthProvider @default(EMAIL)
  googleId          String?   @unique
  appleId           String?   @unique
  refreshTokens     RefreshToken[]
  
  
  emailVerificationExpires DateTime?
  passwordResetToken       String?
  passwordResetExpires     DateTime?
  
  // Profile settings
  isActive          Boolean   @default(true)
  isEmailVerified   Boolean   @default(false)
  wantsEmails       Boolean   @default(true)

  // Push Notifications
  pushToken                    String?
  notificationsEnabled         Boolean   @default(true)
  // Legacy notification fields removed - all notifications now use UserNotificationRule system
  // notifyFollowedFighterFights removed
  // notifyPreEventReport removed
  // notifyHypedFights removed

  // Media/Professional users
  isMedia           Boolean   @default(false)
  mediaOrganization String?
  mediaWebsite      String?

  // Gamification & Stats
  points            Int       @default(0)
  level             Int       @default(1)
  totalRatings      Int       @default(0)
  totalReviews      Int       @default(0)
  upvotesReceived   Int       @default(0)
  downvotesReceived Int       @default(0)
  accuracyScore     Float     @default(0)  // prediction accuracy
  
  // Timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  lastLoginAt       DateTime?
  
  // Relations
  ratings           FightRating[]
  reviews           FightReview[]
  preFightComments  PreFightComment[]
  predictions       FightPrediction[]
  followedFighters  UserFighterFollow[]
  // fightAlerts removed - now using UserNotificationRule system
  reviewVotes       ReviewVote[]
  preFightCommentVotes PreFightCommentVote[]
  activityLog       UserActivity[]
  notifications     UserNotification[]
  notificationRules UserNotificationRule[]

  // Analytics relations
  analyticsEvents   AnalyticsEvent[]
  userSessions      UserSession[]

  // Crew relations
  createdCrews      Crew[]         @relation("CreatedCrews")
  crewMemberships   CrewMember[]
  crewMessages      CrewMessage[]
  crewPredictions   CrewPrediction[]
  crewRoundVotes    CrewRoundVote[]
  crewReactions     CrewReaction[]

  // Feedback relations
  feedback          UserFeedback[]

  @@map("users")
}

enum AuthProvider {
  EMAIL
  GOOGLE
  APPLE
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  @@map("refresh_tokens")
}

// ============== FIGHTERS ==============
model Fighter {
  id              String    @id @default(uuid())
  firstName       String
  lastName        String
  nickname        String?

  // Record
  wins            Int       @default(0)
  losses          Int       @default(0)
  draws           Int       @default(0)
  noContests      Int       @default(0)

  // Profile
  profileImage    String?   // headshot
  actionImage     String?   // action shot
  weightClass     WeightClass?
  rank            String?   // UFC ranking (e.g., "#1", "#5", "C" for champion)
  sport           Sport     @default(MMA)
  gender          Gender
  isActive        Boolean   @default(true)
  isChampion      Boolean   @default(false)
  championshipTitle String?

  // Stats
  averageRating   Float     @default(0)
  totalRatings    Int       @default(0)
  totalFights     Int       @default(0)
  greatFights     Int       @default(0) // fights rated 85+

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  fightsAsFighter1 Fight[]  @relation("Fighter1")
  fightsAsFighter2 Fight[]  @relation("Fighter2")
  followers        UserFighterFollow[]

  @@unique([firstName, lastName])
  @@map("fighters")
}

enum WeightClass {
  // MMA divisions
  STRAWWEIGHT
  FLYWEIGHT
  BANTAMWEIGHT
  FEATHERWEIGHT
  LIGHTWEIGHT
  WELTERWEIGHT
  MIDDLEWEIGHT
  LIGHT_HEAVYWEIGHT
  HEAVYWEIGHT
  SUPER_HEAVYWEIGHT
  // Women's MMA divisions
  WOMENS_STRAWWEIGHT
  WOMENS_FLYWEIGHT
  WOMENS_BANTAMWEIGHT
  WOMENS_FEATHERWEIGHT
  // Boxing divisions (men's)
  BOXING_MINIMUMWEIGHT        // 105 lbs
  BOXING_LIGHT_FLYWEIGHT      // 108 lbs
  BOXING_FLYWEIGHT            // 112 lbs
  BOXING_SUPER_FLYWEIGHT      // 115 lbs
  BOXING_BANTAMWEIGHT         // 118 lbs
  BOXING_SUPER_BANTAMWEIGHT   // 122 lbs
  BOXING_FEATHERWEIGHT        // 126 lbs
  BOXING_SUPER_FEATHERWEIGHT  // 130 lbs
  BOXING_LIGHTWEIGHT          // 135 lbs
  BOXING_SUPER_LIGHTWEIGHT    // 140 lbs
  BOXING_WELTERWEIGHT         // 147 lbs
  BOXING_SUPER_WELTERWEIGHT   // 154 lbs
  BOXING_MIDDLEWEIGHT         // 160 lbs
  BOXING_SUPER_MIDDLEWEIGHT   // 168 lbs
  BOXING_LIGHT_HEAVYWEIGHT    // 175 lbs
  BOXING_CRUISERWEIGHT        // 200 lbs
  BOXING_HEAVYWEIGHT          // 200+ lbs
  // Boxing divisions (women's)
  BOXING_WOMENS_MINIMUMWEIGHT
  BOXING_WOMENS_LIGHT_FLYWEIGHT
  BOXING_WOMENS_FLYWEIGHT
  BOXING_WOMENS_SUPER_FLYWEIGHT
  BOXING_WOMENS_BANTAMWEIGHT
  BOXING_WOMENS_SUPER_BANTAMWEIGHT
  BOXING_WOMENS_FEATHERWEIGHT
  BOXING_WOMENS_SUPER_FEATHERWEIGHT
  BOXING_WOMENS_LIGHTWEIGHT
  BOXING_WOMENS_SUPER_LIGHTWEIGHT
  BOXING_WOMENS_WELTERWEIGHT
  BOXING_WOMENS_SUPER_WELTERWEIGHT
  BOXING_WOMENS_MIDDLEWEIGHT
  BOXING_WOMENS_SUPER_MIDDLEWEIGHT
  BOXING_WOMENS_LIGHT_HEAVYWEIGHT
  BOXING_WOMENS_CRUISERWEIGHT
  BOXING_WOMENS_HEAVYWEIGHT
}

enum Sport {
  MMA
  BOXING
  BARE_KNUCKLE_BOXING
  MUAY_THAI
  KICKBOXING
}

enum Gender {
  MALE
  FEMALE
}

// ============== EVENTS ==============
model Event {
  id                String    @id @default(uuid())
  name              String
  promotion         String    // UFC, Bellator, etc.
  date              DateTime
  venue             String?
  location          String?
  
  // Timing
  earlyPrelimStartTime DateTime?
  prelimStartTime      DateTime?
  mainStartTime        DateTime?
  
  // Media
  bannerImage       String?
  
  // Viewing info
  mainChannel       String?   // ESPN+, DAZN, etc.
  mainLink          String?
  prelimChannel     String?
  prelimLink        String?

  // UFC.com URL for live tracking
  ufcUrl            String?   // e.g., "https://www.ufc.com/event/ufc-320"

  // Stats
  averageRating     Float     @default(0)
  totalRatings      Int       @default(0)
  greatFights       Int       @default(0) // fights rated 85+

  // Status
  hasStarted        Boolean   @default(false)
  isComplete        Boolean   @default(false)
  completionMethod  String?   // "all_fights" | "timeout_12hr" | "timeout_smart" | "manual" | "scraper"

  // Tracker mode override (null = use promotion default from config)
  // "manual" = no automatic updates (for dev/testing)
  // "time-based" = use time-based fallback
  // "live" = use live tracker (if available)
  trackerMode       String?

  // Timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relations
  fights            Fight[]
  sentPreEventNotifications SentPreEventNotification[]

  @@unique([name, date])
  @@unique([ufcUrl])
  @@map("events")
}

// ============== FIGHTS ==============
model Fight {
  id              String    @id @default(uuid())
  
  // Event relationship
  eventId         String
  event           Event     @relation(fields: [eventId], references: [id])
  
  // Fighters
  fighter1Id      String
  fighter1        Fighter   @relation("Fighter1", fields: [fighter1Id], references: [id])
  fighter2Id      String
  fighter2        Fighter   @relation("Fighter2", fields: [fighter2Id], references: [id])
  
  // Fight details
  weightClass     WeightClass?
  isTitle         Boolean   @default(false)
  titleName       String?   // "UFC Heavyweight Championship"
  scheduledRounds Int       @default(3)   // 3 for MMA, 5 for title fights, 8/10/12 for boxing
  orderOnCard     Int       // 1 = main event, higher numbers = earlier fights
  cardType        String?   // "Main Card", "Prelims", "Early Prelims" - from UFC.com scraper
  startTime       String?   // Calculated fight start time (e.g., "10:00 PM")

  // Betting odds
  fighter1Odds    String?   // "-350", "+250", etc.
  fighter2Odds    String?   // "-350", "+250", etc.

  // Result
  winner          String?   // fighter1Id, fighter2Id, or "draw"/"nc"
  method          String?   // "KO", "TKO", "Submission", "Decision"
  round           Int?
  time            String?   // "4:37"
  
  // Ratings & Stats
  averageRating   Float     @default(0)
  totalRatings    Int       @default(0)
  totalReviews    Int       @default(0)
  
  // Rating distribution (for analytics)
  ratings1        Int       @default(0)
  ratings2        Int       @default(0)
  ratings3        Int       @default(0)
  ratings4        Int       @default(0)
  ratings5        Int       @default(0)
  ratings6        Int       @default(0)
  ratings7        Int       @default(0)
  ratings8        Int       @default(0)
  ratings9        Int       @default(0)
  ratings10       Int       @default(0)
  
  // Status
  hasStarted        Boolean   @default(false)
  isComplete        Boolean   @default(false)
  isCancelled       Boolean   @default(false)  // Fight was cancelled before event
  completionMethod  String?   // "scraper" | "failsafe-timeout" | "failsafe-force-timeout" | "manual"
  completedAt       DateTime? // When fight was marked complete
  currentRound      Int?      // Current round in progress (1-5), null if not started or complete
  completedRounds   Int?      // Last completed round number (0-5), null if not started

  // Media
  highlightUrl    String?
  thumbnailUrl    String?
  
  // Watch info
  watchPlatform   String?
  watchUrl        String?
  
  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // Relations
  ratings         FightRating[]
  reviews         FightReview[]
  preFightComments PreFightComment[]
  predictions     FightPrediction[]
  tags            FightTag[]
  // alerts removed - now using UserNotificationRule system

  // Crew relations
  crewMessages      CrewMessage[]
  crewPredictions   CrewPrediction[]
  crewRoundVotes    CrewRoundVote[]
  crewReactions     CrewReaction[]

  @@unique([eventId, fighter1Id, fighter2Id])
  @@map("fights")
}

// ============== RATINGS ==============
model FightRating {
  id                String    @id @default(uuid())

  // Relationships
  userId            String
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  fightId           String
  fight             Fight     @relation(fields: [fightId], references: [id], onDelete: Cascade)

  // Rating
  rating            Int       // 1-10

  // Outcome visibility
  hasRevealedOutcome Boolean  @default(false)

  // Timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@unique([userId, fightId])
  @@map("fight_ratings")
}

// ============== PREDICTIONS ==============
model FightPrediction {
  id              String    @id @default(uuid())

  // Relationships
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  fightId         String
  fight           Fight     @relation(fields: [fightId], references: [id], onDelete: Cascade)

  // Prediction data (all optional to allow flexible predictions)
  predictedRating Int?      // 1-10 how exciting user thinks it will be (optional)
  predictedWinner String?   // fighter1Id or fighter2Id
  predictedMethod PredictionMethod? // Decision, KO/TKO, Submission
  predictedRound  Int?      // 1-5 (depends on fight type)
  confidence      Int       @default(5) // 1-10 scale (optional for now)

  // Accuracy tracking (filled after fight)
  actualRating    Int?      // actual rating user gave after fight
  accuracy        Float?    // calculated accuracy score
  isCorrectWinner Boolean?  // filled after fight
  isCorrectMethod Boolean?
  isCorrectRound  Boolean?
  accuracyScore   Float?    // overall accuracy 0-1

  // Status
  isLocked        Boolean   @default(false) // locked when fight starts

  // Community data visibility - tracks when user has unlocked each section
  hasRevealedHype   Boolean   @default(false) // unlocked after first hype prediction
  hasRevealedWinner Boolean   @default(false) // unlocked after first winner prediction
  hasRevealedMethod Boolean   @default(false) // unlocked after first method prediction

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@unique([userId, fightId])
  @@map("fight_predictions")
}

// ============== REVIEWS ==============
model FightReview {
  id              String    @id @default(uuid())

  // Relationships
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  fightId         String
  fight           Fight     @relation(fields: [fightId], references: [id], onDelete: Cascade)

  // Nested comments support (1 level deep)
  parentReviewId  String?
  parentReview    FightReview?  @relation("FightReviewReplies", fields: [parentReviewId], references: [id], onDelete: Cascade)
  replies         FightReview[] @relation("FightReviewReplies")

  // Review content
  content         String
  rating          Int?      // 1-10 (optional for replies, required for top-level)

  // Media links (for media users)
  articleUrl      String?
  articleTitle    String?

  // Moderation
  isReported      Boolean   @default(false)
  isHidden        Boolean   @default(false)

  // Vote counts
  upvotes         Int       @default(0)
  downvotes       Int       @default(0)

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  votes           ReviewVote[]
  reports         ReviewReport[]

  @@map("fight_reviews")
}

// ============== PRE-FIGHT COMMENTS ==============
model PreFightComment {
  id              String    @id @default(uuid())

  // Relationships
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  fightId         String
  fight           Fight     @relation(fields: [fightId], references: [id], onDelete: Cascade)

  // Nested comments support (1 level deep)
  parentCommentId String?
  parentComment   PreFightComment?  @relation("PreFightCommentReplies", fields: [parentCommentId], references: [id], onDelete: Cascade)
  replies         PreFightComment[] @relation("PreFightCommentReplies")

  // Comment content
  content         String    @db.Text

  // Vote counts
  upvotes         Int       @default(0)

  // Relations
  votes           PreFightCommentVote[]
  reports         PreFightCommentReport[]

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@map("pre_fight_comments")
}

model PreFightCommentVote {
  id        String    @id @default(uuid())

  // Relationships
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  commentId String
  comment   PreFightComment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt DateTime  @default(now())

  @@unique([userId, commentId])
  @@map("pre_fight_comment_votes")
}

model PreFightCommentReport {
  id          String    @id @default(uuid())

  // Relationships
  reporterId  String    // user who reported
  commentId   String
  comment     PreFightComment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  // Report details
  reason      ReportReason
  description String?

  // Status
  isResolved  Boolean   @default(false)

  // Timestamps
  createdAt   DateTime  @default(now())
  resolvedAt  DateTime?

  @@unique([reporterId, commentId])
  @@map("pre_fight_comment_reports")
}

model ReviewVote {
  id        String    @id @default(uuid())
  
  // Relationships
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  reviewId  String
  review    FightReview @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  
  // Vote
  isUpvote  Boolean   // true = upvote, false = downvote
  
  // Timestamps
  createdAt DateTime  @default(now())
  
  @@unique([userId, reviewId])
  @@map("review_votes")
}

model ReviewReport {
  id          String    @id @default(uuid())
  
  // Relationships
  reporterId  String    // user who reported
  reviewId    String
  review      FightReview @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  
  // Report details
  reason      ReportReason
  description String?
  
  // Status
  isResolved  Boolean   @default(false)
  
  // Timestamps
  createdAt   DateTime  @default(now())
  resolvedAt  DateTime?

  @@unique([reporterId, reviewId])
  @@map("review_reports")
}

enum ReportReason {
  SPAM
  HARASSMENT
  PRIVACY
  INAPPROPRIATE_CONTENT
  MISINFORMATION
  OTHER
}

// ============== TAGS ==============
model Tag {
  id          String    @id @default(uuid())
  name        String    @unique
  category    TagCategory
  
  // Display settings
  isActive    Boolean   @default(true)
  sortOrder   Int       @default(0)
  
  // Usage for different rating ranges
  forHighRatings    Boolean @default(false) // 9-10
  forMediumRatings  Boolean @default(false) // 7-8
  forLowRatings     Boolean @default(false) // 5-6
  forVeryLowRatings Boolean @default(false) // 1-4
  
  // Relations
  fightTags   FightTag[]
  
  @@map("tags")
}

enum TagCategory {
  STYLE        // "Technical", "Brawl", "Striking"
  PACE         // "Fast-paced", "Slow burn"
  OUTCOME      // "Knockout", "Submission", "Decision"
  EMOTION      // "Heart", "Brutal", "Inspiring"
  QUALITY      // "FOTY", "FOTN", "Boring"
}

model FightTag {
  id      String @id @default(uuid())
  
  // Relationships
  userId  String
  fightId String
  fight   Fight  @relation(fields: [fightId], references: [id], onDelete: Cascade)
  tagId   String
  tag     Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  // Timestamps
  createdAt DateTime @default(now())
  
  @@unique([userId, fightId, tagId])
  @@map("fight_tags")
}

// ============== FOLLOWS & ALERTS ==============
model UserFighterFollow {
  id        String @id @default(uuid())

  // Relationships
  userId    String
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  fighterId String
  fighter   Fighter @relation(fields: [fighterId], references: [id], onDelete: Cascade)

  // Notification preferences removed - now managed via UserNotificationRule
  // dayBeforeNotification removed
  // startOfFightNotification removed

  // Timestamps
  createdAt DateTime @default(now())

  @@unique([userId, fighterId])
  @@map("user_fighter_follows")
}

// FightAlert table removed - migrated to UserNotificationRule system

// ============== NOTIFICATION RULES ==============
// Extensible rule-based notification system
model UserNotificationRule {
  id        String @id @default(uuid())

  // Relationships
  userId    String
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Rule metadata
  name      String    // User-friendly name: "High hype fights", "UFC Saturdays", etc.
  isActive  Boolean   @default(true)
  priority  Int       @default(0) // Higher priority rules evaluated first

  // Rule conditions (JSON for maximum flexibility)
  // Examples:
  // { "minHype": 8.5 }
  // { "promotions": ["UFC"], "daysOfWeek": [6] }
  // { "fighterIds": ["uuid1", "uuid2"] }
  // { "weightClasses": ["LIGHTWEIGHT"], "isChampionship": true }
  // { "minHype": 9, "promotions": ["UFC"], "notDaysOfWeek": [6] }
  conditions Json

  // Notification settings
  notifyMinutesBefore Int @default(15)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  matches   FightNotificationMatch[]

  @@map("user_notification_rules")
}

// Tracks which fights match which rules for each user
// This is computed/cached and can be refreshed periodically
model FightNotificationMatch {
  id        String @id @default(uuid())

  // Relationships
  userId    String
  fightId   String
  ruleId    String
  rule      UserNotificationRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  // Status
  isActive  Boolean @default(true)  // User can disable per-fight without deleting rule
  notificationSent Boolean @default(false)

  // Metadata
  matchedAt DateTime @default(now()) // When the rule matched

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, fightId, ruleId])
  @@index([userId, fightId])
  @@index([fightId, isActive])
  @@map("fight_notification_matches")
}

// ============== GAMIFICATION ==============
model UserActivity {
  id          String @id @default(uuid())
  
  // Relationships
  userId      String
  user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Activity details
  activityType ActivityType
  points      Int
  description String?
  
  // Context (optional references)
  fightId     String?
  reviewId    String?
  predictionId String?
  
  // Timestamps
  createdAt   DateTime @default(now())
  
  @@map("user_activities")
}

enum ActivityType {
  FIGHT_RATED
  REVIEW_WRITTEN
  PREDICTION_MADE
  PREDICTION_ACCURATE
  REVIEW_UPVOTED
  DAILY_LOGIN
  FIGHTER_FOLLOWED
}

// ============== NOTIFICATIONS ==============
model UserNotification {
  id        String @id @default(uuid())
  
  // Relationships
  userId    String
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Notification content
  title     String
  message   String
  type      NotificationType
  
  // Status
  isRead    Boolean @default(false)
  
  // Optional links
  linkUrl   String?
  linkType  String? // "fight", "event", "review"
  linkId    String?
  
  // Timestamps
  createdAt DateTime @default(now())
  readAt    DateTime?
  
  @@map("user_notifications")
}

enum NotificationType {
  FIGHT_STARTING
  FIGHTER_FIGHTING_SOON
  REVIEW_UPVOTED
  LEVEL_UP
  PREDICTION_RESULT
  SYSTEM_ANNOUNCEMENT
}

// ============== ANALYTICS & RECOMMENDATIONS ==============
model UserRecommendation {
  id        String @id @default(uuid())
  
  // Relationships
  userId    String
  fightId   String
  
  // Recommendation details
  score     Float     // 0-1 confidence score
  reason    String?   // "Based on your ratings of similar fights"
  
  // Status
  isViewed  Boolean   @default(false)
  isRated   Boolean   @default(false)
  
  // Timestamps
  createdAt DateTime  @default(now())
  expiresAt DateTime?
  
  @@unique([userId, fightId])
  @@map("user_recommendations")
}

// ============== ANALYTICS SYSTEM ==============
model AnalyticsEvent {
  id          String @id @default(uuid())

  // Event identification
  eventName   String        // e.g., "user_registered", "fight_rated", "review_posted"
  eventType   EventType

  // User context (nullable for anonymous events)
  userId      String?
  user        User?         @relation(fields: [userId], references: [id], onDelete: SetNull)
  sessionId   String?       // For tracking user sessions

  // Event properties (JSON for flexibility)
  properties  Json?         // e.g., { "fightId": "123", "rating": 8, "platform": "mobile" }

  // Context metadata
  userAgent   String?
  platform    String?       // "ios", "android", "web"
  appVersion  String?
  ipAddress   String?       // For geographic analytics

  // Timestamps
  createdAt   DateTime      @default(now())

  // Indexes for common queries
  @@index([eventName, createdAt])
  @@index([userId, createdAt])
  @@index([eventType, createdAt])
  @@index([platform, createdAt])
  @@map("analytics_events")
}

enum EventType {
  // User lifecycle
  USER_LIFECYCLE     // registration, email_verified, profile_completed

  // Authentication & sessions
  AUTH_SESSION       // login, logout, session_start, session_end

  // Core app actions
  CONTENT_INTERACTION // fight_viewed, fighter_viewed, event_viewed
  USER_ACTION        // fight_rated, review_posted, tag_applied, search_performed

  // Navigation & engagement
  NAVIGATION         // screen_viewed, tab_switched, deep_link_opened
  ENGAGEMENT         // app_opened, app_backgrounded, push_notification_tapped

  // Business metrics
  CONVERSION         // first_rating, first_review, returned_user

  // Technical & errors
  PERFORMANCE        // api_response_time, crash_occurred, error_encountered
}

model UserSession {
  id              String    @id @default(uuid())

  // User context
  userId          String?
  user            User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  sessionId       String    @unique

  // Session metadata
  platform        String?   // "ios", "android", "web"
  appVersion      String?
  deviceId        String?   // Anonymous device identifier

  // Session timing
  startedAt       DateTime  @default(now())
  endedAt         DateTime?
  durationSeconds Int?      // Calculated on session end

  // Session activity metrics
  screenViewCount Int       @default(0)
  eventCount      Int       @default(0)
  ratingsGiven    Int       @default(0)
  reviewsPosted   Int       @default(0)

  // Session outcomes
  wasConverted    Boolean   @default(false) // Did user complete a key action?
  lastScreenName  String?

  @@index([userId, startedAt])
  @@index([sessionId])
  @@map("user_sessions")
}

// Aggregated daily metrics for performance
model DailyMetrics {
  id                    String   @id @default(uuid())
  date                  DateTime @unique @db.Date

  // User metrics
  totalUsers            Int      @default(0)
  newUsers              Int      @default(0)
  activeUsers           Int      @default(0)
  returningUsers        Int      @default(0)

  // Content metrics
  totalRatings          Int      @default(0)
  totalReviews          Int      @default(0)
  totalTags             Int      @default(0)

  // Engagement metrics
  totalSessions         Int      @default(0)
  avgSessionDuration    Float?   // in minutes
  totalScreenViews      Int      @default(0)

  // Fight-specific metrics
  fightsRated           Int      @default(0)
  avgRating             Float?
  fightsViewed          Int      @default(0)

  // Platform breakdown (JSON for flexibility)
  platformMetrics       Json?    // { "ios": {...}, "android": {...}, "web": {...} }

  // Auto-generated timestamp
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([date])
  @@map("daily_metrics")
}

// ============== PRIVATE FIGHT CREWS ==============

// Crew management
model Crew {
  id              String    @id @default(uuid())
  name            String
  description     String?
  imageUrl        String?   // Crew profile image URL

  // Access control
  inviteCode      String    @unique  // 6-8 char code for joining
  isPrivate       Boolean   @default(true)
  maxMembers      Int       @default(20)

  // Creator
  createdBy       String
  creator         User      @relation("CreatedCrews", fields: [createdBy], references: [id])

  // Settings
  allowPredictions Boolean  @default(true)
  allowRoundVoting Boolean  @default(true)
  allowReactions   Boolean  @default(true)
  followOnlyUFC    Boolean  @default(false) // true = only UFC events, false = all events

  // Stats
  totalMembers    Int       @default(1)
  totalMessages   Int       @default(0)
  totalFights     Int       @default(0) // fights watched together

  // Status
  isActive        Boolean   @default(true)

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  members         CrewMember[]
  messages        CrewMessage[]
  predictions     CrewPrediction[]
  roundVotes      CrewRoundVote[]
  reactions       CrewReaction[]

  @@map("crews")
}

// Crew membership
model CrewMember {
  id          String    @id @default(uuid())

  // Relationships
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  crewId      String
  crew        Crew      @relation(fields: [crewId], references: [id], onDelete: Cascade)

  // Role & permissions
  role        CrewRole  @default(MEMBER)

  // Member stats
  messagesCount    Int       @default(0)
  predictionsCount Int       @default(0)
  correctPredictions Int     @default(0)

  // Status
  isActive    Boolean   @default(true)
  isMuted     Boolean   @default(false)
  mutedUntil  DateTime? // null = muted forever, date = muted until that time

  // Timestamps
  joinedAt    DateTime  @default(now())
  lastActiveAt DateTime @default(now())

  @@unique([userId, crewId])
  @@map("crew_members")
}

enum CrewRole {
  OWNER
  ADMIN
  MEMBER
}

// Chat messages (MVP core feature)
model CrewMessage {
  id              String    @id @default(uuid())

  // Relationships
  crewId          String
  crew            Crew      @relation(fields: [crewId], references: [id], onDelete: Cascade)
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Message content
  content         String?   // nullable for structured messages
  messageType     MessageType @default(TEXT)

  // Fight context (for structured messages)
  fightId         String?
  fight           Fight?    @relation(fields: [fightId], references: [id])

  // Structured data (JSON for predictions, votes, etc.)
  structuredData  Json?     // { "predictionData": {...}, "voteData": {...} }

  // Message status
  isEdited        Boolean   @default(false)
  isDeleted       Boolean   @default(false)

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  editedAt        DateTime?

  @@index([crewId, createdAt])
  @@map("crew_messages")
}

enum MessageType {
  TEXT              // Regular chat message
  PREDICTION        // "John predicts Fighter A by KO in Round 2"
  ROUND_VOTE        // "Round 1 voting: Fighter A (3 votes), Fighter B (1 vote)"
  RATING           // "John rated this fight 8/10"
  REACTION         // "ðŸ”¥ John: This round was fire!"
  FIGHT_UPDATE     // "Fight starting now!" (automated)
  FIGHT_RESULT     // "Winner: Fighter A by TKO R2" (automated)
  DELETED          // Deleted message
}

// Predictions (MVP must-have)
model CrewPrediction {
  id              String    @id @default(uuid())

  // Relationships
  crewId          String
  crew            Crew      @relation(fields: [crewId], references: [id], onDelete: Cascade)
  userId          String
  user            User      @relation(fields: [userId], references: [id])
  fightId         String
  fight           Fight     @relation(fields: [fightId], references: [id])

  // Pre-fight prediction data (user's predictions)
  hypeLevel       Int?      // 1-10 how hyped the user is for this fight (optional)
  predictedWinner String?   // fighter1Id or fighter2Id
  predictedMethod PredictionMethod? // Decision, KO/TKO, Submission
  predictedRound  Int?      // 1-5 (depends on fight type)
  confidence      Int       @default(5) // 1-10 scale (optional for now)

  // Result tracking (filled after fight)
  isCorrectWinner Boolean?  // filled after fight
  isCorrectMethod Boolean?
  isCorrectRound  Boolean?
  accuracyScore   Float?    // overall accuracy 0-1

  // Status
  isLocked        Boolean   @default(false) // locked when fight starts

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@unique([crewId, userId, fightId])
  @@map("crew_predictions")
}

enum PredictionMethod {
  DECISION
  KO_TKO
  SUBMISSION
}

// Round voting (MVP must-have)
model CrewRoundVote {
  id          String    @id @default(uuid())

  // Relationships
  crewId      String
  crew        Crew      @relation(fields: [crewId], references: [id], onDelete: Cascade)
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  fightId     String
  fight       Fight     @relation(fields: [fightId], references: [id])

  // Round data
  roundNumber Int       // 1-5
  winner      String    // fighter1Id or fighter2Id
  score       String?   // "10-9", "10-8", etc.

  // Timestamps
  createdAt   DateTime  @default(now())

  @@unique([crewId, userId, fightId, roundNumber])
  @@map("crew_round_votes")
}

// Reactions (Phase 2, but simple to add)
model CrewReaction {
  id          String    @id @default(uuid())

  // Relationships
  crewId      String
  crew        Crew      @relation(fields: [crewId], references: [id], onDelete: Cascade)
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  fightId     String?
  fight       Fight?    @relation(fields: [fightId], references: [id])

  // Reaction data
  emoji       String    // "ðŸ”¥", "ðŸ˜±", "ðŸ¥±", "ðŸ’ª"
  context     String?   // "round_1", "ko_finish", "fight_start"

  // Timestamps
  createdAt   DateTime  @default(now())

  @@map("crew_reactions")
}

// ============== MMA NEWS ==============
model NewsArticle {
  id              String    @id @default(uuid())

  // Article content
  headline        String
  description     String    @default("")
  url             String    @unique
  source          String    // "MMA Fighting", "Bloody Elbow", "UFC", "Bleacher Report"

  // Images
  imageUrl        String?
  localImagePath  String?   // Path to downloaded image (e.g., "/news-images/bloodyelbow-123456.jpg")

  // Status
  isActive        Boolean   @default(true)

  // Timestamps
  scrapedAt       DateTime  @default(now())
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([source, createdAt])
  @@index([createdAt])
  @@map("news_articles")
}

// ============== USER FEEDBACK ==============
model UserFeedback {
  id              String    @id @default(uuid())

  // User relationship (optional - allow anonymous feedback)
  userId          String?
  user            User?     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Feedback content
  content         String    @db.Text
  userEmail       String?   // Store email for anonymous users or backup

  // Metadata
  platform        String?   // "ios", "android", "web"
  appVersion      String?

  // Status
  isRead          Boolean   @default(false)
  isResolved      Boolean   @default(false)
  adminNotes      String?   @db.Text

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([userId, createdAt])
  @@index([createdAt])
  @@map("user_feedback")
}

// ============== PRE-EVENT NOTIFICATIONS TRACKING ==============
model SentPreEventNotification {
  id        String   @id @default(uuid())

  // Event relationship
  eventId   String   @unique
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  // Timestamp
  sentAt    DateTime @default(now())

  @@map("sent_pre_event_notifications")
}

// ============== SCRAPER & LIVE TRACKER LOGS ==============
model ScraperLog {
  id            String    @id @default(uuid())

  // Log type and organization
  type          String    // "daily_scraper" | "live_tracker"
  organization  String    // "UFC", "BKFC", "OKTAGON", etc.
  status        String    // "started" | "completed" | "failed"

  // Event context (for live trackers)
  eventId       String?
  eventName     String?

  // Scraper results
  eventsScraped Int?
  fightsUpdated Int?
  fightersAdded Int?

  // Error tracking
  errorMessage  String?   @db.Text

  // Timing
  duration      Int?      // milliseconds
  startedAt     DateTime
  completedAt   DateTime?

  // Timestamps
  createdAt     DateTime  @default(now())

  @@index([type, createdAt])
  @@index([organization, createdAt])
  @@index([status, createdAt])
  @@map("scraper_logs")
}