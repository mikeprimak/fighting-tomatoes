#!/usr/bin/env node
/**
 * ============================================================================
 * SYNC ALL DATA FROM LIVE LEGACY DATABASE
 * ============================================================================
 *
 * This script connects DIRECTLY to the live fightingtomatoes.com MySQL database
 * and syncs ALL data to the PostgreSQL database.
 *
 * SYNC ORDER (dependencies matter):
 *   1. FIGHTERS - From fightdb.fighters (no dependencies)
 *   2. EVENTS   - From fightdb.fightcards (no dependencies)
 *   3. FIGHTS   - From fightdb.fights (depends on fighters, events)
 *   4. USERS    - From fightdb.users (no dependencies)
 *   5. RATINGS  - From userfightratings.{MD5(email)} (depends on fights, users)
 *   6. TAGS     - From userfighttags.{MD5(email)} (depends on fights, users)
 *   7. REVIEWS  - From fightreviewsdb.{fightid} (isolated - non-fatal)
 *   8. UPVOTES  - From review upvoters field (isolated - non-fatal)
 *
 * USAGE:
 *   node sync-all-from-live.js              # Full sync
 *   node sync-all-from-live.js --dry-run    # Preview without changes
 *   node sync-all-from-live.js --only=X     # Only run specific step
 *
 *   X can be: fighters, events, fights, users, ratings, tags, reviews, upvotes
 *
 * ============================================================================
 */

const mysql = require('mysql2/promise');
const { PrismaClient } = require('@prisma/client');
const crypto = require('crypto');

const prisma = new PrismaClient();

// Legacy MySQL connection (fightingtomatoes.com)
const MYSQL_CONFIG = {
  host: '216.69.165.113',
  port: 3306,
  user: 'fotnadmin',
  password: 'HungryMonkey12',
};

const BASE_IMAGE_URL = 'https://fightingtomatoes.com/';

// Parse command line args
const args = process.argv.slice(2);
const DRY_RUN = args.includes('--dry-run');
const ONLY = args.find(a => a.startsWith('--only='))?.split('=')[1];
const WITH_REVIEWS = args.includes('--with-reviews'); // Reviews are SLOW - skip by default

// Tag name mapping (legacy -> new)
// Legacy tag ID -> New tag UUID mapping
// Generated by setup-legacy-tags.js
const fs = require('fs');
const LEGACY_TAG_MAPPING_PATH = __dirname + '/../legacy-tag-mapping.json';
let LEGACY_TAG_MAPPING = null;

function loadLegacyTagMapping() {
  if (LEGACY_TAG_MAPPING) return LEGACY_TAG_MAPPING;
  try {
    LEGACY_TAG_MAPPING = JSON.parse(fs.readFileSync(LEGACY_TAG_MAPPING_PATH, 'utf8'));
    return LEGACY_TAG_MAPPING;
  } catch (e) {
    console.error('âš ï¸  Could not load legacy-tag-mapping.json - run setup-legacy-tags.js first');
    return {};
  }
}

// Weight class mapping (legacy -> new enum)
const WEIGHT_CLASS_MAP = {
  'strawweight': 'STRAWWEIGHT',
  'flyweight': 'FLYWEIGHT',
  'bantamweight': 'BANTAMWEIGHT',
  'featherweight': 'FEATHERWEIGHT',
  'lightweight': 'LIGHTWEIGHT',
  'welterweight': 'WELTERWEIGHT',
  'middleweight': 'MIDDLEWEIGHT',
  'light heavyweight': 'LIGHT_HEAVYWEIGHT',
  'heavyweight': 'HEAVYWEIGHT',
  'super heavyweight': 'SUPER_HEAVYWEIGHT',
  "women's strawweight": 'WOMENS_STRAWWEIGHT',
  "women's flyweight": 'WOMENS_FLYWEIGHT',
  "women's bantamweight": 'WOMENS_BANTAMWEIGHT',
  "women's featherweight": 'WOMENS_FEATHERWEIGHT',
};

// In-memory mappings built during sync
let legacyFightIdToNewId = new Map();  // Legacy fight ID -> New fight UUID
let legacyUserIdToNewId = new Map();   // Legacy user ID -> New user UUID

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function normalizeName(name) {
  if (!name) return '';
  // 1. Replace special chars that NFKD doesn't decompose (Polish Å‚/Å, etc.)
  // 2. NFKD decomposition splits diacritics into base char + combining mark
  // 3. Strip combining marks, leaving plain ASCII equivalents
  return name
    .replace(/[Å‚Å]/g, 'l')
    .replace(/[Ä‘Ä]/g, 'd')
    .replace(/[Ã¸Ã˜]/g, 'o')
    .replace(/[Ã¦Ã†]/g, 'ae')
    .replace(/[ÃŸáºž]/g, 'ss')
    .normalize('NFKD').replace(/[\u0300-\u036f]/g, '')
    .toLowerCase().replace(/[^a-z0-9]/g, '').trim();
}

/** Strip diacritics but preserve casing, spaces, and punctuation.
 *  Use this when storing names in the DB (human-readable but ASCII-safe). */
function stripDiacritics(name) {
  if (!name) return '';
  return name
    .replace(/[Å‚]/g, 'l').replace(/[Å]/g, 'L')
    .replace(/[Ä‘]/g, 'd').replace(/[Ä]/g, 'D')
    .replace(/[Ã¸]/g, 'o').replace(/[Ã˜]/g, 'O')
    .replace(/[Ã¦]/g, 'ae').replace(/[Ã†]/g, 'Ae')
    .replace(/[ÃŸ]/g, 'ss').replace(/[áºž]/g, 'Ss')
    .normalize('NFKD').replace(/[\u0300-\u036f]/g, '');
}

function normalizeImageUrl(path) {
  if (!path) return null;
  path = path.trim();
  if (!path) return null;
  if (path.includes('blank-fighter-image')) return null;
  if (path.startsWith('http://') || path.startsWith('https://')) {
    return path;
  }
  return BASE_IMAGE_URL + path;
}

function mapWeightClass(legacy) {
  if (!legacy) return null;
  const normalized = legacy.toLowerCase().trim();
  return WEIGHT_CLASS_MAP[normalized] || null;
}

function parseGender(weightClass) {
  if (!weightClass) return 'MALE';
  const normalized = weightClass.toLowerCase();
  return normalized.includes("women") ? 'FEMALE' : 'MALE';
}

// ============================================================================
// MAIN SYNC FUNCTION
// ============================================================================

async function syncAllFromLive() {
  console.log('');
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘        SYNC ALL DATA FROM LIVE LEGACY DATABASE                 â•‘');
  console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
  console.log('â•‘  Source: fightingtomatoes.com (MySQL)                          â•‘');
  console.log('â•‘  Target: PostgreSQL database                                   â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('');

  if (DRY_RUN) {
    console.log('ðŸ” DRY RUN MODE - No changes will be made\n');
  }

  if (ONLY) {
    console.log(`ðŸ“‹ Running only: ${ONLY}\n`);
  }

  const connection = await mysql.createConnection(MYSQL_CONFIG);
  console.log('âœ… Connected to legacy MySQL database\n');

  const results = {
    fighters: { synced: 0, skipped: 0, errors: 0, images: 0 },
    events: { synced: 0, skipped: 0, errors: 0, images: 0 },
    fights: { synced: 0, skipped: 0, errors: 0 },
    users: { synced: 0, skipped: 0, errors: 0 },
    ratings: { synced: 0, skipped: 0, errors: 0 },
    tags: { synced: 0, skipped: 0, errors: 0 },
    reviews: { synced: 0, skipped: 0, errors: 0, failed: false },
    upvotes: { synced: 0, skipped: 0, errors: 0, failed: false },
  };

  try {
    // Critical steps - errors will stop migration
    if (!ONLY || ONLY === 'fighters') {
      results.fighters = await syncFighters(connection);
    }
    if (!ONLY || ONLY === 'events') {
      results.events = await syncEvents(connection);
    }
    if (!ONLY || ONLY === 'fights') {
      results.fights = await syncFights(connection);
    }
    if (!ONLY || ONLY === 'users') {
      results.users = await syncUsers(connection);
    }
    if (!ONLY || ONLY === 'ratings') {
      results.ratings = await syncRatings(connection);
    }
    if (!ONLY || ONLY === 'tags') {
      results.tags = await syncTags(connection);
    }

    // Isolated steps - SKIPPED BY DEFAULT (very slow - 14,241 tables to query)
    // Use --with-reviews to include, or --only=reviews to run separately
    if (ONLY === 'reviews' || (WITH_REVIEWS && !ONLY)) {
      try {
        results.reviews = await syncReviews(connection);
      } catch (err) {
        console.error('âš ï¸  Reviews sync failed (non-fatal):', err.message);
        results.reviews = { synced: 0, skipped: 0, errors: 1, failed: true };
      }
    } else if (!ONLY) {
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.log('STEP 7: REVIEWS - SKIPPED (use --with-reviews to include)');
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      results.reviews = { synced: 0, skipped: 0, errors: 0, failed: false, skippedStep: true };
    }

    if (ONLY === 'upvotes' || (WITH_REVIEWS && !ONLY)) {
      try {
        results.upvotes = await syncReviewUpvotes(connection);
      } catch (err) {
        console.error('âš ï¸  Upvotes sync failed (non-fatal):', err.message);
        results.upvotes = { synced: 0, skipped: 0, errors: 1, failed: true };
      }
    } else if (!ONLY) {
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.log('STEP 8: UPVOTES - SKIPPED (use --with-reviews to include)');
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      results.upvotes = { synced: 0, skipped: 0, errors: 0, failed: false, skippedStep: true };
    }

    // Print summary
    printSummary(results);

  } finally {
    await connection.end();
    await prisma.$disconnect();
  }
}

function printSummary(results) {
  console.log('\n');
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘                      SYNC COMPLETE                             â•‘');
  console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');

  const formatLine = (name, r) => {
    if (r.skippedStep) {
      return `â•‘  â­ï¸  ${name.padEnd(10)} SKIPPED (use --with-reviews)                    â•‘`;
    }
    const status = r.failed ? 'âš ï¸' : 'âœ…';
    return `â•‘  ${status} ${name.padEnd(10)} ${String(r.synced).padStart(6)} synced, ${String(r.skipped).padStart(6)} skip, ${String(r.errors).padStart(4)} err â•‘`;
  };

  console.log(formatLine('Fighters', results.fighters) + ` (${results.fighters.images} with images)`);
  console.log(formatLine('Events', results.events) + ` (${results.events.images} with images)`);
  console.log(formatLine('Fights', results.fights));
  console.log(formatLine('Users', results.users));
  console.log(formatLine('Ratings', results.ratings));
  console.log(formatLine('Tags', results.tags));
  console.log(formatLine('Reviews', results.reviews) + (results.reviews.failed ? ' FAILED' : ''));
  console.log(formatLine('Upvotes', results.upvotes) + (results.upvotes.failed ? ' FAILED' : ''));

  console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
  console.log('â•‘  Next steps:                                                   â•‘');
  console.log('â•‘    cd ../.. && node update-rating-stats.js                     â•‘');
  console.log('â•‘    node ../update-user-stats.js                                â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
}

// ============================================================================
// STEP 1: SYNC FIGHTERS
// ============================================================================

async function syncFighters(connection) {
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('STEP 1: SYNCING FIGHTERS');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

  const result = { synced: 0, skipped: 0, errors: 0, images: 0 };

  await connection.query('USE fightdb');
  const [legacyFighters] = await connection.query(`
    SELECT id, fname, lname, pic1filepath
    FROM fighters
  `);
  console.log(`  Found ${legacyFighters.length} fighters in legacy DB`);

  // Get existing fighters for deduplication
  const existingFighters = await prisma.fighter.findMany({
    select: { id: true, firstName: true, lastName: true }
  });
  const existingSet = new Set(
    existingFighters.map(f => `${normalizeName(f.firstName)}|${normalizeName(f.lastName)}`)
  );
  console.log(`  Found ${existingFighters.length} fighters in new DB`);

  // Batch insert new fighters
  const fightersToCreate = [];
  const seenNames = new Set();

  for (const lf of legacyFighters) {
    const firstName = (lf.fname || '').trim();
    const lastName = (lf.lname || '').trim();
    if (!firstName || !lastName) continue;

    const key = `${normalizeName(firstName)}|${normalizeName(lastName)}`;

    // Skip if already exists in new DB
    if (existingSet.has(key)) {
      result.skipped++;
      continue;
    }

    // Skip if we've already seen this name in this batch (duplicates in legacy)
    if (seenNames.has(key)) {
      result.skipped++;
      continue;
    }
    seenNames.add(key);

    const imageUrl = normalizeImageUrl(lf.pic1filepath);
    if (imageUrl) result.images++;

    fightersToCreate.push({
      firstName: stripDiacritics(firstName),
      lastName: stripDiacritics(lastName),
      profileImage: imageUrl,
      gender: 'MALE', // Default, will be updated when fights are created
    });
  }

  console.log(`  Creating ${fightersToCreate.length} new fighters...`);

  if (!DRY_RUN && fightersToCreate.length > 0) {
    // Use createMany for performance
    try {
      const created = await prisma.fighter.createMany({
        data: fightersToCreate,
        skipDuplicates: true,
      });
      result.synced = created.count;
    } catch (err) {
      // Fall back to individual creates if batch fails
      console.log('  Batch insert failed, falling back to individual creates...');
      for (const fighter of fightersToCreate) {
        try {
          await prisma.fighter.create({ data: fighter });
          result.synced++;
        } catch (e) {
          result.errors++;
        }
      }
    }
  } else {
    result.synced = fightersToCreate.length;
  }

  console.log(`  âœ… Fighters sync complete: ${result.synced} synced, ${result.images} with images\n`);
  return result;
}

// ============================================================================
// STEP 2: SYNC EVENTS
// ============================================================================

async function syncEvents(connection) {
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('STEP 2: SYNCING EVENTS');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

  const result = { synced: 0, skipped: 0, errors: 0, images: 0 };

  await connection.query('USE fightdb');
  const [legacyEvents] = await connection.query(`
    SELECT id, promotion, eventname, date, pic1filepath
    FROM fightcards
    ORDER BY date DESC
  `);
  console.log(`  Found ${legacyEvents.length} events in legacy DB`);

  // Get existing events for deduplication
  const existingEvents = await prisma.event.findMany({
    select: { id: true, name: true, date: true }
  });
  const existingSet = new Set(
    existingEvents.map(e => `${normalizeName(e.name)}|${e.date.toISOString().split('T')[0]}`)
  );
  console.log(`  Found ${existingEvents.length} events in new DB`);

  // Process events
  const eventsToCreate = [];
  const seenEvents = new Set();

  for (const le of legacyEvents) {
    const promotion = (le.promotion || '').trim();
    const rawEventName = (le.eventname || '').trim();
    if (!rawEventName) continue;

    // Normalize event name (e.g., "200" -> "UFC 200")
    let eventName = rawEventName;
    if (/^\d+$/.test(rawEventName)) {
      eventName = `${promotion} ${rawEventName}`;
    } else if (!rawEventName.toLowerCase().includes(promotion.toLowerCase())) {
      if (rawEventName.includes(':')) {
        eventName = `${promotion}: ${rawEventName.split(':').slice(1).join(':').trim()}`;
      } else if (/^Fight\s*Night/i.test(rawEventName)) {
        eventName = `${promotion} ${rawEventName}`;
      }
    }

    const eventDate = le.date ? new Date(le.date) : new Date();
    const dateStr = eventDate.toISOString().split('T')[0];
    const key = `${normalizeName(eventName)}|${dateStr}`;

    if (existingSet.has(key) || seenEvents.has(key)) {
      result.skipped++;
      continue;
    }
    seenEvents.add(key);

    const imageUrl = normalizeImageUrl(le.pic1filepath);
    if (imageUrl) result.images++;

    eventsToCreate.push({
      name: stripDiacritics(eventName),
      promotion,
      date: eventDate,
      bannerImage: imageUrl,
    });
  }

  console.log(`  Creating ${eventsToCreate.length} new events...`);

  if (!DRY_RUN && eventsToCreate.length > 0) {
    try {
      const created = await prisma.event.createMany({
        data: eventsToCreate,
        skipDuplicates: true,
      });
      result.synced = created.count;
    } catch (err) {
      console.log('  Batch insert failed:', err.message.split('\n')[0]);
      console.log('  Falling back to individual creates...');
      for (const event of eventsToCreate) {
        try {
          await prisma.event.create({ data: event });
          result.synced++;
        } catch (e) {
          result.errors++;
          if (result.errors <= 5) {
            console.log(`    Error creating "${event.name}": ${e.message.split('\n')[0]}`);
          }
        }
      }
    }
  } else {
    result.synced = eventsToCreate.length;
  }

  console.log(`  âœ… Events sync complete: ${result.synced} synced, ${result.images} with images\n`);
  return result;
}

// ============================================================================
// STEP 3: SYNC FIGHTS
// ============================================================================

async function syncFights(connection) {
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('STEP 3: SYNCING FIGHTS');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

  const result = { synced: 0, skipped: 0, errors: 0 };

  await connection.query('USE fightdb');
  const [legacyFights] = await connection.query(`
    SELECT id, f1fn, f1ln, f2fn, f2ln, eventname, promotion, date,
           winner, method, round, time, weightclass, istitle,
           orderoncard, prelimcode, hasstarted, percentscore, numvotes
    FROM fights WHERE deleted = 0
  `);
  console.log(`  Found ${legacyFights.length} fights in legacy DB`);

  // Get all fighters from new DB
  const fighters = await prisma.fighter.findMany({
    select: { id: true, firstName: true, lastName: true }
  });
  const fighterMap = new Map();
  for (const f of fighters) {
    fighterMap.set(`${normalizeName(f.firstName)}|${normalizeName(f.lastName)}`, f.id);
  }
  console.log(`  Loaded ${fighters.length} fighters for matching`);

  // Get all events from new DB
  const events = await prisma.event.findMany({
    select: { id: true, name: true, date: true, promotion: true }
  });
  const eventMap = new Map();
  for (const e of events) {
    const dateStr = e.date.toISOString().split('T')[0];
    eventMap.set(`${normalizeName(e.name)}|${dateStr}`, e.id);
    eventMap.set(`${normalizeName(e.name)}|${e.promotion}`, e.id);
  }
  console.log(`  Loaded ${events.length} events for matching`);

  // Get existing fights for deduplication
  const existingFights = await prisma.fight.findMany({
    select: { id: true, fighter1Id: true, fighter2Id: true, eventId: true }
  });
  const existingSet = new Set(
    existingFights.map(f => `${f.fighter1Id}|${f.fighter2Id}|${f.eventId}`)
  );
  console.log(`  Found ${existingFights.length} existing fights`);

  let processed = 0;
  for (const lf of legacyFights) {
    const f1Key = `${normalizeName(lf.f1fn)}|${normalizeName(lf.f1ln)}`;
    const f2Key = `${normalizeName(lf.f2fn)}|${normalizeName(lf.f2ln)}`;
    const fighter1Id = fighterMap.get(f1Key);
    const fighter2Id = fighterMap.get(f2Key);

    if (!fighter1Id || !fighter2Id) {
      result.errors++;
      continue;
    }

    // Find event - must apply the SAME name normalization as syncEvents
    const eventDate = lf.date ? new Date(lf.date).toISOString().split('T')[0] : '';
    let eventName = (lf.eventname || '').trim();
    const promotion = (lf.promotion || '').trim();
    if (/^\d+$/.test(eventName)) {
      eventName = `${promotion} ${eventName}`;
    } else if (!eventName.toLowerCase().includes(promotion.toLowerCase())) {
      if (eventName.includes(':')) {
        eventName = `${promotion}: ${eventName.split(':').slice(1).join(':').trim()}`;
      } else if (/^Fight\s*Night/i.test(eventName)) {
        eventName = `${promotion} ${eventName}`;
      }
    }
    const eventKey1 = `${normalizeName(eventName)}|${eventDate}`;
    const eventKey2 = `${normalizeName(eventName)}|${promotion}`;
    const eventId = eventMap.get(eventKey1) || eventMap.get(eventKey2);

    if (!eventId) {
      result.errors++;
      continue;
    }

    // Check for existing fight
    const fightKey = `${fighter1Id}|${fighter2Id}|${eventId}`;
    const fightKeyReverse = `${fighter2Id}|${fighter1Id}|${eventId}`;
    if (existingSet.has(fightKey) || existingSet.has(fightKeyReverse)) {
      result.skipped++;
      // Still build the mapping for ratings/tags
      const existingFight = existingFights.find(f =>
        (f.fighter1Id === fighter1Id && f.fighter2Id === fighter2Id && f.eventId === eventId) ||
        (f.fighter1Id === fighter2Id && f.fighter2Id === fighter1Id && f.eventId === eventId)
      );
      if (existingFight) {
        legacyFightIdToNewId.set(lf.id, existingFight.id);
      }
      continue;
    }

    // Determine winner
    let winnerId = null;
    if (lf.winner === 'fighter1') winnerId = fighter1Id;
    else if (lf.winner === 'fighter2') winnerId = fighter2Id;
    else if (lf.winner === 'draw') winnerId = 'draw';
    else if (lf.winner === 'nc') winnerId = 'nc';

    const fightData = {
      eventId,
      fighter1Id,
      fighter2Id,
      weightClass: mapWeightClass(lf.weightclass),
      isTitle: !!lf.istitle,
      orderOnCard: lf.orderoncard || 99,
      winner: winnerId,
      method: lf.method || null,
      round: lf.round ? parseInt(lf.round) : null,
      time: lf.time || null,
      hasStarted: !!lf.hasstarted || (lf.date && new Date(lf.date) < new Date()),
      isComplete: !!lf.winner || (lf.date && new Date(lf.date) < new Date()),
      averageRating: lf.percentscore ? parseFloat(lf.percentscore) / 10 : 0,
      totalRatings: lf.numvotes || 0,
    };

    if (!DRY_RUN) {
      try {
        const newFight = await prisma.fight.create({ data: fightData });
        legacyFightIdToNewId.set(lf.id, newFight.id);
        existingSet.add(fightKey);
        result.synced++;
      } catch (e) {
        result.errors++;
      }
    } else {
      result.synced++;
    }

    processed++;
    if (processed % 2000 === 0) {
      console.log(`    Processed ${processed}/${legacyFights.length} fights...`);
    }
  }

  console.log(`  Built fight ID mapping: ${legacyFightIdToNewId.size} mappings`);

  // Reverse fight order: legacy stores 1=opener, N=main event
  // App convention is 1=main event (displayed first)
  if (!DRY_RUN && result.synced > 0) {
    console.log('  Reversing fight order (legacy=chronological â†’ app=main-event-first)...');
    const reversed = await prisma.$executeRaw`
      UPDATE fights f
      SET "orderOnCard" = sub.max_order - f."orderOnCard" + 1
      FROM (
        SELECT "eventId", MAX("orderOnCard") as max_order
        FROM fights
        GROUP BY "eventId"
        HAVING COUNT(*) > 1
      ) sub
      WHERE f."eventId" = sub."eventId"
    `;
    console.log(`  Reversed order for ${reversed} fights`);
  }

  // Mark past events as complete
  if (!DRY_RUN) {
    const now = new Date();
    const markedComplete = await prisma.event.updateMany({
      where: { date: { lt: now }, isComplete: false },
      data: { isComplete: true },
    });
    if (markedComplete.count > 0) {
      console.log(`  Marked ${markedComplete.count} past events as isComplete=true`);
    }
  }

  console.log(`  âœ… Fights sync complete: ${result.synced} synced, ${result.errors} errors\n`);
  return result;
}

// ============================================================================
// STEP 4: SYNC USERS
// ============================================================================

async function syncUsers(connection) {
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('STEP 4: SYNCING USERS');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

  const result = { synced: 0, skipped: 0, errors: 0 };

  await connection.query('USE fightdb');
  const [legacyUsers] = await connection.query(`
    SELECT id, emailaddress, displayname, ismedia, mediaorganization,
           reviewerscore, numreviews
    FROM users
  `);
  console.log(`  Found ${legacyUsers.length} users in legacy DB`);

  // Get existing users
  const existingUsers = await prisma.user.findMany({
    select: { id: true, email: true }
  });
  const existingEmails = new Set(existingUsers.map(u => u.email.toLowerCase()));
  console.log(`  Found ${existingUsers.length} users in new DB`);

  // Build mapping for existing users
  for (const user of existingUsers) {
    const legacyUser = legacyUsers.find(
      lu => lu.emailaddress?.toLowerCase() === user.email.toLowerCase()
    );
    if (legacyUser) {
      legacyUserIdToNewId.set(legacyUser.id, user.id);
    }
  }

  const usersToCreate = [];

  for (const lu of legacyUsers) {
    const email = (lu.emailaddress || '').toLowerCase().trim();
    if (!email) continue;

    if (existingEmails.has(email)) {
      result.skipped++;
      continue;
    }

    usersToCreate.push({
      email,
      displayName: lu.displayname || null,
      password: null, // Triggers claim flow
      isMedia: !!lu.ismedia,
      mediaOrganization: lu.mediaorganization || null,
      emailVerified: true, // Legacy users were already confirmed
      isEmailVerified: true,
    });
  }

  console.log(`  Creating ${usersToCreate.length} new users...`);

  if (!DRY_RUN && usersToCreate.length > 0) {
    for (const userData of usersToCreate) {
      try {
        const newUser = await prisma.user.create({ data: userData });

        // Find legacy user to build mapping
        const legacyUser = legacyUsers.find(
          lu => lu.emailaddress?.toLowerCase() === userData.email
        );
        if (legacyUser) {
          legacyUserIdToNewId.set(legacyUser.id, newUser.id);
        }

        result.synced++;
      } catch (e) {
        result.errors++;
      }
    }
  } else {
    result.synced = usersToCreate.length;
  }

  console.log(`  Built user ID mapping: ${legacyUserIdToNewId.size} mappings`);
  console.log(`  âœ… Users sync complete: ${result.synced} synced (password=null for claim flow)\n`);
  return result;
}

// ============================================================================
// STEP 5: SYNC RATINGS
// ============================================================================

async function syncRatings(connection) {
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('STEP 5: SYNCING RATINGS');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

  const result = { synced: 0, skipped: 0, errors: 0 };

  // If we don't have fight mappings, rebuild them
  if (legacyFightIdToNewId.size === 0) {
    console.log('  Building fight ID mappings...');
    await buildFightMappings(connection);
  }

  // Get users from new DB
  const users = await prisma.user.findMany({ select: { id: true, email: true } });
  console.log(`  Found ${users.length} users in new DB`);

  // Get existing ratings for deduplication
  const existingRatings = await prisma.fightRating.findMany({
    select: { fightId: true, userId: true }
  });
  const existingRatingKeys = new Set(existingRatings.map(r => `${r.fightId}|${r.userId}`));
  console.log(`  Found ${existingRatings.length} existing ratings`);

  let processed = 0;
  let usersWithRatings = 0;
  const ratingsToCreate = [];

  // For each user, find their ratings table by MD5(email)
  for (const user of users) {
    const emailMd5 = crypto.createHash('md5').update(user.email.toLowerCase()).digest('hex');

    try {
      await connection.query('USE userfightratings');
      const [ratings] = await connection.query(`SELECT * FROM \`${emailMd5}\``);
      if (ratings.length === 0) continue;
      usersWithRatings++;

      for (const rating of ratings) {
        const legacyFightId = parseInt(rating.fightid, 10);
        const newFightId = legacyFightIdToNewId.get(legacyFightId);
        if (!newFightId) continue;

        const key = `${newFightId}|${user.id}`;
        if (existingRatingKeys.has(key)) {
          result.skipped++;
          continue;
        }

        let createdAt = new Date();
        if (rating.time_of_rating) {
          const parsed = new Date(rating.time_of_rating);
          if (!isNaN(parsed.getTime())) {
            createdAt = parsed;
          }
        }

        ratingsToCreate.push({
          fightId: newFightId,
          userId: user.id,
          rating: rating.score,
          createdAt,
        });
        existingRatingKeys.add(key);
      }
    } catch (e) {
      // Table doesn't exist for this user - that's fine
    }

    processed++;
    if (processed % 200 === 0) {
      console.log(`    Processed ${processed}/${users.length} users (${usersWithRatings} with ratings)...`);
    }
  }

  console.log(`  Found ${usersWithRatings} users with ratings`);
  console.log(`  Creating ${ratingsToCreate.length} ratings...`);

  if (!DRY_RUN && ratingsToCreate.length > 0) {
    // Batch create in chunks of 1000
    const chunkSize = 1000;
    for (let i = 0; i < ratingsToCreate.length; i += chunkSize) {
      const chunk = ratingsToCreate.slice(i, i + chunkSize);
      try {
        const created = await prisma.fightRating.createMany({
          data: chunk,
          skipDuplicates: true,
        });
        result.synced += created.count;
      } catch (e) {
        result.errors += chunk.length;
      }
    }
  } else {
    result.synced = ratingsToCreate.length;
  }

  console.log(`  âœ… Ratings sync complete: ${result.synced} synced\n`);
  return result;
}

// ============================================================================
// STEP 6: SYNC TAGS (Fixed - uses MD5(email) not maptoemail)
// ============================================================================

async function syncTags(connection) {
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('STEP 6: SYNCING TAGS');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

  const result = { synced: 0, skipped: 0, errors: 0 };

  // If we don't have fight mappings, rebuild them
  if (legacyFightIdToNewId.size === 0) {
    console.log('  Building fight ID mappings...');
    await buildFightMappings(connection);
  }

  // Load legacy tag ID -> new tag UUID mapping
  // Generated by setup-legacy-tags.js
  const legacyTagMapping = loadLegacyTagMapping();
  const legacyTagCount = Object.keys(legacyTagMapping).length;
  if (legacyTagCount === 0) {
    console.log('  âš ï¸  No tag mapping found - run setup-legacy-tags.js first');
    return result;
  }
  console.log(`  Loaded ${legacyTagCount} legacy tag mappings`);

  // Get users from new DB
  const users = await prisma.user.findMany({ select: { id: true, email: true } });
  console.log(`  Found ${users.length} users in new DB`);

  // Get existing tags for deduplication
  const existingTags = await prisma.fightTag.findMany({
    select: { userId: true, fightId: true, tagId: true }
  });
  const existingTagKeys = new Set(existingTags.map(t => `${t.userId}|${t.fightId}|${t.tagId}`));
  console.log(`  Found ${existingTags.length} existing tags`);

  let processed = 0;
  let usersWithTags = 0;
  const tagsToCreate = [];

  // For each user, find their tags table by MD5(email)
  // NOTE: This is the FIX - we use MD5(email), NOT the maptoemail column
  for (const user of users) {
    const emailMd5 = crypto.createHash('md5').update(user.email.toLowerCase()).digest('hex');

    try {
      await connection.query('USE userfighttags');
      const [tags] = await connection.query(`SELECT * FROM \`${emailMd5}\``);
      if (tags.length === 0) continue;
      usersWithTags++;

      for (const tag of tags) {
        const legacyFightId = parseInt(tag.fightid, 10);
        const newFightId = legacyFightIdToNewId.get(legacyFightId);
        if (!newFightId) continue;

        // Direct mapping: legacy tagid -> new tag UUID
        const newTagId = legacyTagMapping[tag.tagid];
        if (!newTagId) continue;

        const tagId = newTagId;

        const key = `${user.id}|${newFightId}|${tagId}`;
        if (existingTagKeys.has(key)) {
          result.skipped++;
          continue;
        }

        tagsToCreate.push({
          userId: user.id,
          fightId: newFightId,
          tagId,
        });
        existingTagKeys.add(key);
      }
    } catch (e) {
      // Table doesn't exist for this user - that's fine
    }

    processed++;
    if (processed % 200 === 0) {
      console.log(`    Processed ${processed}/${users.length} users (${usersWithTags} with tags)...`);
    }
  }

  console.log(`  Found ${usersWithTags} users with tags`);
  console.log(`  Creating ${tagsToCreate.length} tags...`);

  if (!DRY_RUN && tagsToCreate.length > 0) {
    try {
      const created = await prisma.fightTag.createMany({
        data: tagsToCreate,
        skipDuplicates: true,
      });
      result.synced = created.count;
    } catch (e) {
      result.errors = tagsToCreate.length;
    }
  } else {
    result.synced = tagsToCreate.length;
  }

  console.log(`  âœ… Tags sync complete: ${result.synced} synced\n`);
  return result;
}

// ============================================================================
// STEP 7: SYNC REVIEWS (Isolated - non-fatal)
// ============================================================================

async function syncReviews(connection) {
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('STEP 7: SYNCING REVIEWS (isolated)');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

  const result = { synced: 0, skipped: 0, errors: 0, failed: false };

  // If we don't have fight mappings, rebuild them
  if (legacyFightIdToNewId.size === 0) {
    console.log('  Building fight ID mappings...');
    await buildFightMappings(connection);
  }

  // Get users by email
  const users = await prisma.user.findMany({ select: { id: true, email: true } });
  const userByEmail = new Map(users.map(u => [u.email.toLowerCase(), u.id]));
  console.log(`  Found ${users.length} users`);

  // Get existing reviews for deduplication
  const existingReviews = await prisma.fightReview.findMany({
    select: { userId: true, fightId: true, content: true }
  });
  const existingKeys = new Set(
    existingReviews.map(r => `${r.userId}|${r.fightId}|${normalizeName(r.content?.substring(0, 50) || '')}`)
  );

  // Get all review tables
  await connection.query('USE fightreviewsdb');
  const [tables] = await connection.query('SHOW TABLES');
  const tableKey = Object.keys(tables[0])[0];
  console.log(`  Checking ${tables.length} review tables...`);

  let processed = 0;
  for (const table of tables) {
    const tableName = table[tableKey];
    const legacyFightId = parseInt(tableName, 10);
    if (isNaN(legacyFightId)) continue;

    const newFightId = legacyFightIdToNewId.get(legacyFightId);
    if (!newFightId) continue;

    try {
      const [columns] = await connection.query(`DESCRIBE \`${tableName}\``);
      if (!columns.some(c => c.Field === 'comment')) continue;

      const [reviews] = await connection.query(`SELECT * FROM \`${tableName}\``);
      if (reviews.length === 0) continue;

      for (const review of reviews) {
        const email = (review.commenteremail || '').toLowerCase().trim();
        const userId = userByEmail.get(email);
        if (!userId) continue;

        const reviewKey = `${userId}|${newFightId}|${normalizeName(review.comment?.substring(0, 50) || '')}`;
        if (existingKeys.has(reviewKey)) {
          result.skipped++;
          continue;
        }

        if (!DRY_RUN) {
          try {
            await prisma.fightReview.create({
              data: {
                fightId: newFightId,
                userId,
                content: review.comment || '',
                upvotes: review.helpful || 0,
                createdAt: review.date ? (review.date > 1000000000 ? new Date(review.date * 1000) : new Date(review.date, 0, 1)) : new Date(),
              }
            });
            result.synced++;
            existingKeys.add(reviewKey);
          } catch (e) {
            result.errors++;
          }
        } else {
          result.synced++;
        }
      }
    } catch (e) {
      // Skip problematic tables
    }

    processed++;
    if (processed % 2000 === 0) {
      console.log(`    Processed ${processed}/${tables.length} tables...`);
    }
  }

  console.log(`  âœ… Reviews sync complete: ${result.synced} synced\n`);
  return result;
}

// ============================================================================
// STEP 8: SYNC REVIEW UPVOTES (Isolated - non-fatal)
// ============================================================================

async function syncReviewUpvotes(connection) {
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('STEP 8: SYNCING REVIEW UPVOTES (isolated)');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

  const result = { synced: 0, skipped: 0, errors: 0, failed: false };

  // If we don't have user mappings, rebuild them
  if (legacyUserIdToNewId.size === 0) {
    console.log('  Building user ID mappings...');
    await buildUserMappings(connection);
  }

  // Get reviews from new DB
  const reviews = await prisma.fightReview.findMany({
    select: { id: true, userId: true, fightId: true, content: true }
  });
  console.log(`  Found ${reviews.length} reviews`);

  // Get existing votes for deduplication
  const existingVotes = await prisma.reviewVote.findMany({
    select: { userId: true, reviewId: true }
  });
  const existingVoteKeys = new Set(existingVotes.map(v => `${v.userId}|${v.reviewId}`));
  console.log(`  Found ${existingVotes.length} existing votes`);

  // If we don't have fight mappings, rebuild them
  if (legacyFightIdToNewId.size === 0) {
    console.log('  Building fight ID mappings...');
    await buildFightMappings(connection);
  }

  // Get all review tables and parse upvoters
  await connection.query('USE fightreviewsdb');
  const [tables] = await connection.query('SHOW TABLES');
  const tableKey = Object.keys(tables[0])[0];

  let processed = 0;
  for (const table of tables) {
    const tableName = table[tableKey];
    const legacyFightId = parseInt(tableName, 10);
    if (isNaN(legacyFightId)) continue;

    const newFightId = legacyFightIdToNewId.get(legacyFightId);
    if (!newFightId) continue;

    try {
      const [columns] = await connection.query(`DESCRIBE \`${tableName}\``);
      if (!columns.some(c => c.Field === 'upvoters')) continue;

      const [legacyReviews] = await connection.query(`SELECT * FROM \`${tableName}\``);

      for (const legacyReview of legacyReviews) {
        if (!legacyReview.upvoters) continue;

        // Decode upvoters buffer to string like "-46--914-"
        let decoded = '';
        if (Buffer.isBuffer(legacyReview.upvoters)) {
          decoded = legacyReview.upvoters.toString('utf8');
        } else if (typeof legacyReview.upvoters === 'string') {
          decoded = legacyReview.upvoters;
        } else if (legacyReview.upvoters.data) {
          decoded = Buffer.from(legacyReview.upvoters.data).toString('utf8');
        }

        const upvoterIds = decoded.match(/\d+/g) || [];
        if (upvoterIds.length === 0) continue;

        // Find matching new review by fightId + content
        const matchingReview = reviews.find(
          r => r.fightId === newFightId &&
               normalizeName(r.content?.substring(0, 50)) === normalizeName(legacyReview.comment?.substring(0, 50))
        );
        if (!matchingReview) continue;

        for (const legacyUserId of upvoterIds) {
          const newUserId = legacyUserIdToNewId.get(parseInt(legacyUserId));
          if (!newUserId) {
            result.skipped++;
            continue;
          }

          const voteKey = `${newUserId}|${matchingReview.id}`;
          if (existingVoteKeys.has(voteKey)) {
            result.skipped++;
            continue;
          }

          if (!DRY_RUN) {
            try {
              await prisma.reviewVote.create({
                data: {
                  userId: newUserId,
                  reviewId: matchingReview.id,
                  isUpvote: true,
                }
              });
              result.synced++;
              existingVoteKeys.add(voteKey);
            } catch (e) {
              result.errors++;
            }
          } else {
            result.synced++;
          }
        }
      }
    } catch (e) {
      // Skip problematic tables
    }

    processed++;
    if (processed % 2000 === 0) {
      console.log(`    Processed ${processed}/${tables.length} tables...`);
    }
  }

  console.log(`  âœ… Upvotes sync complete: ${result.synced} synced\n`);
  return result;
}

// ============================================================================
// HELPER: BUILD FIGHT MAPPINGS
// ============================================================================

async function buildFightMappings(connection) {
  await connection.query('USE fightdb');
  const [legacyFights] = await connection.query(`
    SELECT id, f1fn, f1ln, f2fn, f2ln, eventname, promotion, date
    FROM fights WHERE deleted = 0
  `);

  const fighters = await prisma.fighter.findMany({
    select: { id: true, firstName: true, lastName: true }
  });
  const fighterMap = new Map();
  for (const f of fighters) {
    fighterMap.set(`${normalizeName(f.firstName)}|${normalizeName(f.lastName)}`, f.id);
  }

  const newFights = await prisma.fight.findMany({
    select: { id: true, fighter1Id: true, fighter2Id: true, eventId: true }
  });
  const fightLookup = new Map();
  for (const f of newFights) {
    fightLookup.set(`${f.fighter1Id}|${f.fighter2Id}|${f.eventId}`, f.id);
    fightLookup.set(`${f.fighter2Id}|${f.fighter1Id}|${f.eventId}`, f.id);
  }

  const events = await prisma.event.findMany({
    select: { id: true, name: true, date: true }
  });
  const eventMap = new Map();
  for (const e of events) {
    const dateStr = e.date.toISOString().split('T')[0];
    eventMap.set(`${normalizeName(e.name)}|${dateStr}`, e.id);
  }

  for (const lf of legacyFights) {
    const f1Key = `${normalizeName(lf.f1fn)}|${normalizeName(lf.f1ln)}`;
    const f2Key = `${normalizeName(lf.f2fn)}|${normalizeName(lf.f2ln)}`;
    const fighter1Id = fighterMap.get(f1Key);
    const fighter2Id = fighterMap.get(f2Key);
    if (!fighter1Id || !fighter2Id) continue;

    const eventDate = lf.date ? new Date(lf.date).toISOString().split('T')[0] : '';
    let eventName = (lf.eventname || '').trim();
    const promotion = (lf.promotion || '').trim();
    if (/^\d+$/.test(eventName)) {
      eventName = `${promotion} ${eventName}`;
    } else if (!eventName.toLowerCase().includes(promotion.toLowerCase())) {
      if (eventName.includes(':')) {
        eventName = `${promotion}: ${eventName.split(':').slice(1).join(':').trim()}`;
      } else if (/^Fight\s*Night/i.test(eventName)) {
        eventName = `${promotion} ${eventName}`;
      }
    }
    const eventId = eventMap.get(`${normalizeName(eventName)}|${eventDate}`);
    if (!eventId) continue;

    const fightKey1 = `${fighter1Id}|${fighter2Id}|${eventId}`;
    const fightKey2 = `${fighter2Id}|${fighter1Id}|${eventId}`;
    const newFightId = fightLookup.get(fightKey1) || fightLookup.get(fightKey2);
    if (newFightId) {
      legacyFightIdToNewId.set(lf.id, newFightId);
    }
  }

  console.log(`  Built ${legacyFightIdToNewId.size} fight mappings`);
}

// ============================================================================
// HELPER: BUILD USER MAPPINGS
// ============================================================================

async function buildUserMappings(connection) {
  await connection.query('USE fightdb');
  const [legacyUsers] = await connection.query(`
    SELECT id, emailaddress FROM users
  `);

  const newUsers = await prisma.user.findMany({
    select: { id: true, email: true }
  });

  for (const newUser of newUsers) {
    const legacyUser = legacyUsers.find(
      lu => lu.emailaddress?.toLowerCase() === newUser.email.toLowerCase()
    );
    if (legacyUser) {
      legacyUserIdToNewId.set(legacyUser.id, newUser.id);
    }
  }

  console.log(`  Built ${legacyUserIdToNewId.size} user mappings`);
}

// ============================================================================
// RUN
// ============================================================================

syncAllFromLive().catch(err => {
  console.error('Fatal error:', err);
  process.exit(1);
});
